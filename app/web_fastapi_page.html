<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM Lab - Signal Console</title>
  <link rel="icon" type="image/png" href="/assets/logo/llm-lab-logo.png">
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Noto+Sans+SC:wght@400;500;700&family=IBM+Plex+Mono:wght@400;500&display=swap");

    :root {
      --void-950: #070d14;
      --void-900: #0d1822;
      --void-800: #122332;
      --void-700: #1b3345;
      --text-100: #e8f2f8;
      --text-300: #b3c6d3;
      --text-500: #7892a6;
      --cyan-400: #18c4d1;
      --cyan-500: #12aeba;
      --lime-400: #9fe870;
      --amber-400: #f3b25d;
      --line: rgba(110, 191, 228, 0.28);
      --line-soft: rgba(110, 191, 228, 0.14);
      --glow: 0 0 0 1px rgba(24, 196, 209, 0.2), 0 20px 52px rgba(2, 10, 18, 0.58);
      --radius-xl: 22px;
      --radius-lg: 16px;
      --radius-md: 12px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      min-height: 100%;
      color: var(--text-100);
      background:
        radial-gradient(900px 650px at -8% -18%, rgba(24, 196, 209, 0.2) 0%, rgba(24, 196, 209, 0) 66%),
        radial-gradient(1100px 720px at 112% -16%, rgba(243, 178, 93, 0.2) 0%, rgba(243, 178, 93, 0) 64%),
        linear-gradient(150deg, var(--void-950) 0%, #0a1420 42%, #0c1b28 100%);
      font-family: "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.26;
      background-image:
        linear-gradient(transparent 95%, rgba(24, 196, 209, 0.2) 100%),
        linear-gradient(90deg, transparent 95%, rgba(24, 196, 209, 0.18) 100%);
      background-size: 36px 36px, 36px 36px;
      mask-image: radial-gradient(circle at center, black 38%, transparent 88%);
    }

    body::after {
      content: "";
      position: fixed;
      inset: -120% -20% auto;
      height: 32%;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(24, 196, 209, 0), rgba(24, 196, 209, 0.11), rgba(24, 196, 209, 0));
      animation: scan-sweep 8s linear infinite;
      mix-blend-mode: screen;
      opacity: 0.65;
    }

    .shell {
      width: min(1180px, calc(100vw - 40px));
      margin: 26px auto 34px;
      display: grid;
      gap: 16px;
      animation: stage-fade 700ms ease forwards;
      position: relative;
    }

    .hero {
      position: relative;
      overflow: hidden;
      border: 1px solid var(--line);
      border-radius: var(--radius-xl);
      background:
        linear-gradient(130deg, rgba(13, 24, 34, 0.87), rgba(12, 28, 40, 0.74)),
        linear-gradient(35deg, rgba(24, 196, 209, 0.1), rgba(243, 178, 93, 0.06));
      box-shadow: var(--glow);
      padding: 24px 26px 20px;
      isolation: isolate;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(24, 196, 209, 0.09), rgba(24, 196, 209, 0));
      pointer-events: none;
      z-index: -1;
    }

    .hero::after {
      content: "";
      position: absolute;
      width: 260px;
      height: 260px;
      border-radius: 50%;
      right: -110px;
      top: -110px;
      background: radial-gradient(circle at center, rgba(243, 178, 93, 0.32), rgba(243, 178, 93, 0));
      pointer-events: none;
      filter: blur(2px);
    }

    .kicker {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--text-300);
    }

    .kicker::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--cyan-400);
      box-shadow: 0 0 0 6px rgba(24, 196, 209, 0.15);
      animation: pulse-dot 1.7s ease infinite;
    }

    .hero h1 {
      margin: 10px 0 9px;
      font-family: "Orbitron", sans-serif;
      font-size: clamp(30px, 4vw, 46px);
      line-height: 1.05;
      letter-spacing: 0.02em;
      color: #f3fbff;
      text-shadow: 0 0 26px rgba(24, 196, 209, 0.24);
    }

    .hero p {
      margin: 0;
      max-width: 720px;
      color: var(--text-300);
      line-height: 1.6;
      font-size: 15px;
    }

    .hero-meta {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .meta-item {
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid var(--line-soft);
      background: rgba(7, 13, 20, 0.5);
    }

    .meta-item span {
      display: block;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-500);
      font-family: "IBM Plex Mono", monospace;
    }

    .meta-item b {
      display: block;
      margin-top: 4px;
      font-size: 15px;
      color: var(--text-100);
      font-family: "Orbitron", sans-serif;
      font-weight: 500;
    }

    .dashboard {
      display: grid;
      grid-template-columns: minmax(280px, 330px) 1fr;
      gap: 16px;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius-xl);
      background: linear-gradient(165deg, rgba(14, 27, 38, 0.9), rgba(10, 20, 30, 0.86));
      box-shadow: var(--glow);
    }

    .control-panel {
      padding: 16px;
      position: relative;
      overflow: hidden;
    }

    .control-panel::after {
      content: "";
      position: absolute;
      width: 280px;
      height: 280px;
      border-radius: 42px;
      transform: rotate(28deg);
      right: -180px;
      bottom: -170px;
      background: linear-gradient(155deg, rgba(24, 196, 209, 0.24), rgba(243, 178, 93, 0.12));
      pointer-events: none;
      filter: blur(4px);
    }

    .card-title {
      margin: 0;
      font-family: "Orbitron", sans-serif;
      font-size: 20px;
      letter-spacing: 0.04em;
      color: #f4fbff;
    }

    .card-subtitle {
      margin: 7px 0 14px;
      color: var(--text-500);
      font-size: 12px;
    }

    .telemetry {
      margin-bottom: 12px;
      padding: 10px 11px;
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      background: rgba(7, 13, 20, 0.46);
      position: relative;
      z-index: 1;
    }

    .telemetry-item + .telemetry-item {
      margin-top: 9px;
    }

    .telemetry-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-family: "IBM Plex Mono", monospace;
      color: var(--text-500);
    }

    .telemetry-track {
      height: 7px;
      border-radius: 999px;
      background: rgba(120, 146, 166, 0.22);
      overflow: hidden;
      border: 1px solid rgba(120, 146, 166, 0.2);
    }

    .telemetry-fill {
      display: block;
      height: 100%;
      width: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--cyan-500), var(--lime-400));
      box-shadow: 0 0 18px rgba(24, 196, 209, 0.42);
      transition: width 220ms ease;
    }

    .field {
      margin-bottom: 11px;
      position: relative;
      z-index: 1;
    }

    .field label {
      display: block;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--text-300);
      font-weight: 600;
      letter-spacing: 0.09em;
      text-transform: uppercase;
      font-family: "IBM Plex Mono", monospace;
    }

    .field select,
    .field textarea,
    .field input[type="range"] {
      width: 100%;
    }

    .field select,
    .field textarea {
      border: 1px solid rgba(110, 191, 228, 0.27);
      border-radius: 11px;
      background: rgba(9, 18, 27, 0.78);
      padding: 10px 11px;
      font: inherit;
      color: var(--text-100);
      outline: none;
      transition: border-color 180ms ease, box-shadow 180ms ease, background 180ms ease;
    }

    .field select:focus,
    .field textarea:focus {
      border-color: rgba(24, 196, 209, 0.78);
      box-shadow: 0 0 0 3px rgba(24, 196, 209, 0.18);
      background: rgba(8, 17, 26, 0.92);
    }

    .range-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-top: 6px;
    }

    .range-value {
      width: 50px;
      text-align: right;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      color: var(--text-300);
    }

    input[type="range"] {
      accent-color: var(--cyan-400);
    }

    .switch-row {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px dashed rgba(110, 191, 228, 0.3);
      border-radius: 11px;
      padding: 10px 11px;
      position: relative;
      z-index: 1;
      background: rgba(8, 16, 24, 0.54);
    }

    .switch-label {
      font-size: 12px;
      color: var(--text-300);
    }

    .toggle {
      width: 48px;
      height: 28px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: rgba(120, 146, 166, 0.42);
      position: relative;
      transition: background 180ms ease;
    }

    .toggle::after {
      content: "";
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #f4fcff;
      left: 3px;
      top: 3px;
      transition: transform 180ms ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.46);
    }

    .toggle[data-on="true"] {
      background: var(--cyan-500);
      box-shadow: 0 0 20px rgba(24, 196, 209, 0.35);
    }

    .toggle[data-on="true"]::after {
      transform: translateX(20px);
    }

    .chat-panel {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 660px;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--line-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      background: rgba(8, 16, 24, 0.6);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .live-state {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(24, 196, 209, 0.25);
      font-size: 11px;
      font-family: "IBM Plex Mono", monospace;
      color: var(--text-300);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(8, 16, 24, 0.72);
    }

    .pulse {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--lime-400);
      box-shadow: 0 0 0 6px rgba(159, 232, 112, 0.18);
      animation: pulse-dot 1.5s ease infinite;
    }

    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(110, 191, 228, 0.3);
      background: rgba(8, 17, 26, 0.68);
      font-size: 11px;
      color: var(--text-300);
      font-family: "IBM Plex Mono", monospace;
      letter-spacing: 0.03em;
    }

    .chat-feed {
      padding: 16px;
      overflow-y: auto;
      display: grid;
      gap: 11px;
      align-content: start;
      background: linear-gradient(180deg, rgba(8, 17, 26, 0.42), rgba(8, 17, 26, 0.68));
    }

    .bubble {
      max-width: min(78ch, 88%);
      padding: 12px 13px;
      border-radius: 13px 13px 13px 4px;
      border: 1px solid rgba(110, 191, 228, 0.24);
      background: rgba(10, 22, 34, 0.88);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      animation: bubble-in 260ms cubic-bezier(.21, 1.1, .36, 1) forwards;
      color: var(--text-100);
    }

    .bubble.user {
      margin-left: auto;
      border-radius: 13px 13px 4px 13px;
      background: linear-gradient(130deg, rgba(24, 196, 209, 0.2), rgba(24, 196, 209, 0.12));
      border-color: rgba(24, 196, 209, 0.44);
      box-shadow: 0 0 20px rgba(24, 196, 209, 0.18);
    }

    .bubble.assistant {
      box-shadow: 0 10px 20px rgba(1, 9, 14, 0.4);
    }

    .bubble.thinking {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--text-500);
      background: rgba(9, 18, 28, 0.8);
      border-style: dashed;
      animation: bubble-in 260ms cubic-bezier(.21, 1.1, .36, 1) forwards, thinking-fade 1.1s ease infinite alternate;
    }

    .bubble.reasoning-panel {
      border-style: dashed;
      border-color: rgba(243, 178, 93, 0.4);
      background: rgba(12, 24, 34, 0.86);
      box-shadow: 0 10px 20px rgba(1, 9, 14, 0.28);
    }

    .reasoning-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 11px;
      color: var(--text-300);
      letter-spacing: 0.03em;
    }

    .reasoning-title {
      color: var(--amber-400);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .reasoning-meta {
      color: var(--text-500);
      text-align: right;
      white-space: nowrap;
    }

    .reasoning-preview,
    .reasoning-full {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      line-height: 1.55;
      color: var(--text-300);
    }

    .reasoning-preview {
      max-height: 240px;
      overflow: auto;
    }

    .reasoning-full {
      margin-top: 9px;
      padding-top: 9px;
      border-top: 1px dashed rgba(110, 191, 228, 0.26);
      max-height: 320px;
      overflow: auto;
      color: var(--text-100);
    }

    .reasoning-toggle {
      margin-top: 10px;
      border: 1px solid rgba(243, 178, 93, 0.52);
      border-radius: 9px;
      background: rgba(243, 178, 93, 0.16);
      color: #f7d7a7;
      font-size: 11px;
      font-family: "IBM Plex Mono", monospace;
      padding: 6px 10px;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }

    .reasoning-toggle:hover {
      background: rgba(243, 178, 93, 0.24);
      transform: translateY(-1px);
    }

    .composer {
      border-top: 1px solid var(--line-soft);
      padding: 12px;
      background: rgba(7, 14, 21, 0.82);
    }

    .composer textarea {
      resize: vertical;
      min-height: 80px;
      max-height: 220px;
    }

    .actions {
      margin-top: 9px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .hint {
      font-size: 11px;
      color: var(--text-500);
      letter-spacing: 0.02em;
    }

    .button {
      border: 1px solid rgba(24, 196, 209, 0.55);
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      color: #ecfcff;
      background: linear-gradient(110deg, rgba(18, 174, 186, 0.96), rgba(24, 196, 209, 0.66));
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 180ms ease, opacity 120ms ease;
      box-shadow: 0 12px 24px rgba(7, 98, 111, 0.42);
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(7, 98, 111, 0.5);
    }

    .button:active {
      transform: translateY(1px);
    }

    .button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .button.clear {
      border-color: rgba(243, 178, 93, 0.55);
      background: linear-gradient(110deg, rgba(243, 178, 93, 0.92), rgba(243, 178, 93, 0.62));
      box-shadow: 0 12px 24px rgba(138, 84, 23, 0.36);
    }

    .status {
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-300);
      min-height: 18px;
      font-family: "IBM Plex Mono", monospace;
      letter-spacing: 0.03em;
    }

    .status.error {
      color: #ff8f88;
    }

    .reveal {
      opacity: 0;
      transform: translateY(12px);
      animation: reveal-up 480ms ease forwards;
    }

    .r2 {
      animation-delay: 120ms;
    }

    .r3 {
      animation-delay: 220ms;
    }

    @keyframes reveal-up {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes stage-fade {
      from {
        opacity: 0;
        transform: translateY(12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bubble-in {
      from {
        opacity: 0;
        transform: translateY(8px) scale(0.99);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes pulse-dot {
      0% { box-shadow: 0 0 0 0 rgba(159, 232, 112, 0.3); }
      100% { box-shadow: 0 0 0 8px rgba(159, 232, 112, 0); }
    }

    @keyframes scan-sweep {
      from { transform: translateY(0); }
      to { transform: translateY(300%); }
    }

    @keyframes thinking-fade {
      from { opacity: 0.6; }
      to { opacity: 1; }
    }

    @media (max-width: 980px) {
      .shell {
        width: min(100vw, calc(100vw - 20px));
        margin: 12px auto 18px;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }

      .chat-panel {
        min-height: 70vh;
      }

      .hero-meta {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="hero reveal">
      <div class="kicker">LLM LAB / SIGNAL CONSOLE</div>
      <h1>LLM-LAB</h1>
      <p>
        这个页面聚焦于“快速试验 + 清晰反馈”：你可以调参数、切换模型、追踪回复状态，
        保持一个高密度、可视化、具备控制台气质的对话工作流。
      </p>
      <div class="hero-meta">
        <div class="meta-item">
          <span>Engine State</span>
          <b>Online</b>
        </div>
        <div class="meta-item">
          <span>Pipeline</span>
          <b>Realtime</b>
        </div>
        <div class="meta-item">
          <span>Mode</span>
          <b>Research</b>
        </div>
      </div>
    </section>

    <section class="dashboard">
      <aside class="panel control-panel reveal r2">
        <h2 class="card-title">实验参数</h2>
        <p class="card-subtitle">调整参数后，右侧对话区实时反馈变化。</p>

        <div class="telemetry">
          <div class="telemetry-item">
            <div class="telemetry-label">
              <span>Sampling Flux</span>
              <span id="tempPercent">35%</span>
            </div>
            <div class="telemetry-track"><i id="tempMeter" class="telemetry-fill"></i></div>
          </div>
          <div class="telemetry-item">
            <div class="telemetry-label">
              <span>Nucleus Field</span>
              <span id="topPPercent">90%</span>
            </div>
            <div class="telemetry-track"><i id="topPMeter" class="telemetry-fill"></i></div>
          </div>
          <div class="telemetry-item">
            <div class="telemetry-label">
              <span>Session Energy</span>
              <span id="turnEnergy">0%</span>
            </div>
            <div class="telemetry-track"><i id="turnMeter" class="telemetry-fill"></i></div>
          </div>
        </div>

        <div class="field">
          <label for="profileSelect">Profile</label>
          <select id="profileSelect">
            <option value="dashscope_qwen">dashscope_qwen</option>
            <option value="openai_default">openai_default</option>
            <option value="glm_default">glm_default</option>
          </select>
        </div>

        <div class="field">
          <label for="modelSelect">Model</label>
          <select id="modelSelect">
            <option value="qwen-max">qwen-max</option>
            <option value="qwen-plus">qwen-plus</option>
            <option value="gpt-4o-mini">gpt-4o-mini</option>
          </select>
        </div>

        <div class="field">
          <label for="systemPrompt">System Prompt</label>
          <textarea id="systemPrompt" rows="4">你是 Brench 的 AI 助手。先给结论，再给可执行步骤，保持简洁。</textarea>
        </div>

        <div class="field">
          <label for="temperatureRange">Temperature</label>
          <div class="range-row">
            <input id="temperatureRange" type="range" min="0" max="2" step="0.05" value="0.70">
            <span id="temperatureValue" class="range-value">0.70</span>
          </div>
        </div>

        <div class="field">
          <label for="topPRange">Top-p</label>
          <div class="range-row">
            <input id="topPRange" type="range" min="0" max="1" step="0.05" value="0.90">
            <span id="topPValue" class="range-value">0.90</span>
          </div>
        </div>

        <div class="switch-row">
          <span class="switch-label">Thinking Mode</span>
          <button id="thinkingToggle" class="toggle" type="button" data-on="false" aria-label="Toggle thinking mode"></button>
        </div>

        <div class="switch-row">
          <span class="switch-label">流式输出</span>
          <button id="streamToggle" class="toggle" type="button" data-on="true" aria-label="Toggle stream output"></button>
        </div>
      </aside>

      <section class="panel chat-panel reveal r3">
        <header class="chat-header">
          <div class="chip-list" id="runtimeChips">
            <span class="chip">Profile: -</span>
            <span class="chip">Model: -</span>
            <span class="chip">Turns: 0</span>
          </div>
          <div class="header-right">
            <span class="live-state"><i class="pulse"></i>Realtime</span>
            <button id="clearButton" class="button clear" type="button">清空会话</button>
          </div>
        </header>

        <section id="chatFeed" class="chat-feed">
          <article class="bubble assistant">
            控制台已就绪。输入一条消息开始测试。
          </article>
        </section>

        <form id="composerForm" class="composer">
          <div class="field" style="margin: 0;">
            <textarea
              id="userInput"
              rows="3"
              placeholder="输入你的问题，按 Enter 发送，Shift+Enter 换行..."
            ></textarea>
          </div>
          <div class="actions">
            <span class="hint">开启实时输出可逐步看到回复内容，关闭后将一次性展示完整结果。</span>
            <button id="sendButton" class="button" type="submit">发送消息</button>
          </div>
          <div id="statusBar" class="status"></div>
        </form>
      </section>
    </section>
  </main>

  <script>
    const appState = {
      profile: "dashscope_qwen",
      model: "qwen-max",
      turns: 0,
      thinking: false,
      stream: true,
      temperature: 0.70,
      topP: 0.90,
      history: [],
      profileCatalog: {},
      suppressSwitchHandlers: false
    };

    const profileSelect = document.getElementById("profileSelect");
    const modelSelect = document.getElementById("modelSelect");
    const temperatureRange = document.getElementById("temperatureRange");
    const topPRange = document.getElementById("topPRange");
    const temperatureValue = document.getElementById("temperatureValue");
    const topPValue = document.getElementById("topPValue");
    const thinkingToggle = document.getElementById("thinkingToggle");
    const streamToggle = document.getElementById("streamToggle");
    const runtimeChips = document.getElementById("runtimeChips");
    const chatFeed = document.getElementById("chatFeed");
    const statusBar = document.getElementById("statusBar");
    const composerForm = document.getElementById("composerForm");
    const userInput = document.getElementById("userInput");
    const systemPrompt = document.getElementById("systemPrompt");
    const sendButton = document.getElementById("sendButton");
    const clearButton = document.getElementById("clearButton");

    const tempMeter = document.getElementById("tempMeter");
    const topPMeter = document.getElementById("topPMeter");
    const turnMeter = document.getElementById("turnMeter");
    const tempPercent = document.getElementById("tempPercent");
    const topPPercent = document.getElementById("topPPercent");
    const turnEnergy = document.getElementById("turnEnergy");
    const REASONING_PREVIEW_LIMIT = 420;

    function escapeHtml(text) {
      return text
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function renderRuntimeChips() {
      runtimeChips.innerHTML = `
        <span class="chip">Profile: ${escapeHtml(appState.profile)}</span>
        <span class="chip">Model: ${escapeHtml(appState.model)}</span>
        <span class="chip">实时输出: ${appState.stream ? "开启" : "关闭"}</span>
        <span class="chip">Turns: ${appState.turns}</span>
      `;
      renderTelemetry();
    }

    function renderTelemetry() {
      const tempRatio = Math.max(0, Math.min(100, Math.round((appState.temperature / 2) * 100)));
      const topPRatio = Math.max(0, Math.min(100, Math.round(appState.topP * 100)));
      const turnRatio = Math.max(0, Math.min(100, appState.turns * 12));

      tempMeter.style.width = `${tempRatio}%`;
      topPMeter.style.width = `${topPRatio}%`;
      turnMeter.style.width = `${turnRatio}%`;

      tempPercent.textContent = `${tempRatio}%`;
      topPPercent.textContent = `${topPRatio}%`;
      turnEnergy.textContent = `${turnRatio}%`;
    }

    function pushBubble(role, text, extraClass = "") {
      const node = document.createElement("article");
      node.className = `bubble ${role} ${extraClass}`.trim();
      node.innerHTML = escapeHtml(text);
      chatFeed.appendChild(node);
      chatFeed.scrollTop = chatFeed.scrollHeight;
      return node;
    }

    function setStatus(text, isError = false) {
      statusBar.textContent = text;
      statusBar.classList.toggle("error", Boolean(isError));
    }

    function hasConversationContext() {
      return appState.history.length > 0 || appState.turns > 0;
    }

    function saveContextSnapshot(triggerReason) {
      const storageKey = "llm_lab_context_snapshots";
      let snapshots = [];
      try {
        snapshots = JSON.parse(localStorage.getItem(storageKey) || "[]");
      } catch (_error) {
        snapshots = [];
      }

      const snapshot = {
        saved_at: new Date().toISOString(),
        trigger_reason: triggerReason,
        profile: appState.profile,
        model: appState.model,
        turns: appState.turns,
        history: appState.history
      };
      snapshots.unshift(snapshot);
      localStorage.setItem(storageKey, JSON.stringify(snapshots.slice(0, 30)));
      return snapshot;
    }

    function askSaveBeforeSwitch(nextProfile, nextModel) {
      if (!hasConversationContext()) {
        return;
      }

      const confirmText = [
        "检测到当前对话上下文。",
        `即将切换到 Profile=${nextProfile} / Model=${nextModel}。`,
        "是否先保存当前上下文快照？",
        "确定 = 保存后切换，取消 = 不保存直接切换。"
      ].join("\n");
      const shouldSave = window.confirm(confirmText);
      if (!shouldSave) {
        return;
      }
      saveContextSnapshot("switch_model_or_profile");
      setStatus("已保存当前会话快照。");
    }

    function updateRanges() {
      appState.temperature = Number(temperatureRange.value);
      appState.topP = Number(topPRange.value);
      temperatureValue.textContent = appState.temperature.toFixed(2);
      topPValue.textContent = appState.topP.toFixed(2);
      renderTelemetry();
    }

    function populateProfileOptions() {
      const profileIds = Object.keys(appState.profileCatalog);
      if (!profileIds.length) {
        return;
      }

      profileSelect.innerHTML = profileIds
        .map((profileId) => `<option value="${escapeHtml(profileId)}">${escapeHtml(profileId)}</option>`)
        .join("");
      if (!profileIds.includes(appState.profile)) {
        appState.profile = profileIds[0];
      }
      appState.suppressSwitchHandlers = true;
      profileSelect.value = appState.profile;
      appState.suppressSwitchHandlers = false;
    }

    function populateModelOptions(profileId, preferredModel = "") {
      const profileItem = appState.profileCatalog[profileId];
      const modelOptions = profileItem?.models || [];
      if (!modelOptions.length) {
        return;
      }

      modelSelect.innerHTML = modelOptions
        .map((modelName) => `<option value="${escapeHtml(modelName)}">${escapeHtml(modelName)}</option>`)
        .join("");

      const nextModel = preferredModel && modelOptions.includes(preferredModel)
        ? preferredModel
        : modelOptions[0];
      appState.suppressSwitchHandlers = true;
      appState.model = nextModel;
      modelSelect.value = nextModel;
      appState.suppressSwitchHandlers = false;
    }

    async function bootstrapRuntime() {
      try {
        const response = await fetch("/api/bootstrap", {method: "GET"});
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        const catalog = {};
        for (const profileItem of data.profiles || []) {
          catalog[profileItem.profile_id] = profileItem;
        }
        appState.profileCatalog = catalog;

        if (data.default_profile) {
          appState.profile = data.default_profile;
        }
        populateProfileOptions();
        populateModelOptions(appState.profile, data.default_model || "");

        setStatus("界面已准备就绪。");
        renderRuntimeChips();
      } catch (_error) {
        setStatus("初始化失败，已使用默认配置。", true);
      }
    }

    async function requestAssistant(messageText) {
      const payload = {
        message: messageText,
        history: appState.history,
        system_prompt: systemPrompt.value,
        temperature: appState.temperature,
        top_p: appState.topP,
        enable_thinking: appState.thinking,
        profile: appState.profile,
        model: appState.model
      };

      try {
        const response = await fetch("/api/chat", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        return {
          assistantText: data.assistant_text || "",
          reasoningText: data.reasoning_text || "",
          warningText: (data.warning_messages || []).join(" | "),
          errorText: data.error_message || "",
          resolvedProfile: data.profile || appState.profile,
          resolvedModel: data.model || appState.model
        };
      } catch (_error) {
        const fallback = `已收到：${messageText}\n\n当前连接不稳定，已自动使用备用回复。`;
        return {
          assistantText: fallback,
          reasoningText: "",
          warningText: "连接不稳定，已自动切换备用回复。",
          errorText: "",
          resolvedProfile: appState.profile,
          resolvedModel: appState.model
        };
      }
    }

    async function requestAssistantStream(messageText, onToken) {
      const payload = {
        message: messageText,
        history: appState.history,
        system_prompt: systemPrompt.value,
        temperature: appState.temperature,
        top_p: appState.topP,
        enable_thinking: appState.thinking,
        profile: appState.profile,
        model: appState.model
      };

      try {
        const response = await fetch("/api/chat/stream", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(payload)
        });
        if (!response.ok || !response.body) {
          throw new Error(`HTTP ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let activeEvent = "";
        let donePayload = null;
        let streamError = "";

        while (true) {
          const {value, done} = await reader.read();
          if (done) {
            break;
          }
          buffer += decoder.decode(value, {stream: true});

          while (buffer.includes("\n\n")) {
            const splitIndex = buffer.indexOf("\n\n");
            const rawEvent = buffer.slice(0, splitIndex);
            buffer = buffer.slice(splitIndex + 2);

            const lines = rawEvent.split("\n");
            let payloadText = "";
            activeEvent = "";
            for (const line of lines) {
              if (line.startsWith("event:")) {
                activeEvent = line.slice(6).trim();
                continue;
              }
              if (line.startsWith("data:")) {
                payloadText += line.slice(5).trim();
              }
            }

            if (!activeEvent || !payloadText) {
              continue;
            }

            const eventPayload = JSON.parse(payloadText);
            if (activeEvent === "token") {
              onToken(eventPayload.delta || "");
              continue;
            }
            if (activeEvent === "error") {
              streamError = eventPayload.error_message || "Unknown stream error.";
              continue;
            }
            if (activeEvent === "done") {
              donePayload = eventPayload;
            }
          }
        }

        if (!donePayload) {
          throw new Error(streamError || "Missing done payload from stream endpoint.");
        }

        return {
          assistantText: donePayload.assistant_text || "",
          reasoningText: donePayload.reasoning_text || "",
          warningText: (donePayload.warning_messages || []).join(" | "),
          errorText: donePayload.error_message || streamError || "",
          resolvedProfile: donePayload.profile || appState.profile,
          resolvedModel: donePayload.model || appState.model
        };
      } catch (_error) {
        const fallback = await requestAssistant(messageText);
        return {
          assistantText: fallback.assistantText,
          reasoningText: fallback.reasoningText || "",
          warningText: fallback.warningText || "连接异常，已自动切换为普通回复模式。",
          errorText: fallback.errorText,
          resolvedProfile: fallback.resolvedProfile,
          resolvedModel: fallback.resolvedModel
        };
      }
    }

    function setBubbleText(node, text) {
      node.innerHTML = escapeHtml(text);
      chatFeed.scrollTop = chatFeed.scrollHeight;
    }

    function parseReasoningAndAnswer(rawText) {
      const source = typeof rawText === "string" ? rawText : "";
      const reasoningParts = [];
      const blockPattern = /<think>([\s\S]*?)<\/think>/gi;
      let match = null;

      while ((match = blockPattern.exec(source)) !== null) {
        const reasoningBlock = (match[1] || "").trim();
        if (reasoningBlock) {
          reasoningParts.push(reasoningBlock);
        }
      }

      const lowerSource = source.toLowerCase();
      const openIndex = lowerSource.lastIndexOf("<think>");
      const closeIndex = lowerSource.lastIndexOf("</think>");
      let answerBaseText = source;
      if (openIndex !== -1 && openIndex > closeIndex) {
        const tailReasoning = source.slice(openIndex + 7).trim();
        if (tailReasoning) {
          reasoningParts.push(tailReasoning);
        }
        answerBaseText = source.slice(0, openIndex);
      }

      const answerText = answerBaseText
        .replace(/<think>([\s\S]*?)<\/think>/gi, "")
        .replaceAll("<think>", "")
        .replaceAll("</think>", "")
        .trim();

      return {
        answerText: answerText,
        reasoningText: reasoningParts.join("\n\n").trim(),
      };
    }

    function createReasoningPanel() {
      const container = document.createElement("article");
      container.className = "bubble assistant reasoning-panel";
      container.dataset.expanded = "false";

      const header = document.createElement("div");
      header.className = "reasoning-head";

      const title = document.createElement("span");
      title.className = "reasoning-title";
      title.textContent = "思考过程";

      const meta = document.createElement("span");
      meta.className = "reasoning-meta";
      meta.textContent = "生成中";

      header.appendChild(title);
      header.appendChild(meta);

      const preview = document.createElement("pre");
      preview.className = "reasoning-preview";
      preview.textContent = "模型正在思考...";

      const full = document.createElement("pre");
      full.className = "reasoning-full";
      full.hidden = true;

      const toggle = document.createElement("button");
      toggle.className = "reasoning-toggle";
      toggle.type = "button";
      toggle.hidden = true;
      toggle.textContent = "下展查看思考";
      toggle.addEventListener("click", () => {
        const expanded = container.dataset.expanded === "true";
        container.dataset.expanded = expanded ? "false" : "true";
        const nextExpanded = container.dataset.expanded === "true";
        full.hidden = !nextExpanded;
        toggle.textContent = nextExpanded ? "收起思考" : "下展查看思考";
        chatFeed.scrollTop = chatFeed.scrollHeight;
      });

      container.appendChild(header);
      container.appendChild(preview);
      container.appendChild(full);
      container.appendChild(toggle);
      chatFeed.appendChild(container);
      chatFeed.scrollTop = chatFeed.scrollHeight;

      return {
        container: container,
        meta: meta,
        preview: preview,
        full: full,
        toggle: toggle,
      };
    }

    function updateReasoningPanel(panel, reasoningText, streaming) {
      const normalized = (reasoningText || "").trim();
      panel.meta.textContent = streaming ? "生成中" : "已完成";

      if (!normalized) {
        panel.preview.textContent = streaming ? "模型正在思考..." : "";
        panel.full.textContent = "";
        panel.full.hidden = true;
        panel.toggle.hidden = true;
        panel.container.dataset.expanded = "false";
        return;
      }

      panel.full.textContent = normalized;
      const shouldCollapse = normalized.length > REASONING_PREVIEW_LIMIT;
      panel.preview.textContent = shouldCollapse
        ? `${normalized.slice(0, REASONING_PREVIEW_LIMIT)}...`
        : normalized;
      panel.toggle.hidden = false;
      const expanded = panel.container.dataset.expanded === "true";
      panel.full.hidden = !expanded;
      if (shouldCollapse) {
        panel.toggle.textContent = expanded ? "收起思考" : "下展查看完整思考";
        return;
      }
      panel.toggle.textContent = expanded ? "收起思考" : "展开思考详情";
    }

    async function handleSend() {
      if (sendButton.disabled) {
        return;
      }

      const rawText = userInput.value.trim();
      if (!rawText) {
        setStatus("请输入内容后再发送。", true);
        return;
      }

      sendButton.disabled = true;
      setStatus(appState.stream ? "正在生成回复（实时输出）..." : "正在生成回复...");
      pushBubble("user", rawText);
      appState.history.push({role: "user", content: rawText});
      userInput.value = "";

      const reasoningPanel = createReasoningPanel();
      const assistantNode = pushBubble("assistant", "", "");
      let streamRawText = "";
      let streamReasoningText = "";
      let streamAnswerText = "";
      let result = null;
      if (appState.stream) {
        result = await requestAssistantStream(rawText, (delta) => {
          streamRawText += delta;
          const parsed = parseReasoningAndAnswer(streamRawText);
          streamReasoningText = parsed.reasoningText;
          streamAnswerText = parsed.answerText;
          updateReasoningPanel(reasoningPanel, streamReasoningText, true);
          setBubbleText(assistantNode, streamAnswerText || "...");
        });
      } else {
        result = await requestAssistant(rawText);
      }

      appState.profile = result.resolvedProfile;
      appState.model = result.resolvedModel;
      if (profileSelect.value !== appState.profile) {
        profileSelect.value = appState.profile;
      }
      if (modelSelect.value !== appState.model) {
        populateModelOptions(appState.profile, appState.model);
      }

      const parsedFinal = parseReasoningAndAnswer(result.assistantText || "");
      const reasoningText = (result.reasoningText || streamReasoningText || parsedFinal.reasoningText || "").trim();
      const assistantText = (parsedFinal.answerText || result.assistantText || streamAnswerText || streamRawText || "").trim()
        || (result.errorText ? `请求失败：${result.errorText}` : "模型返回为空。");

      setBubbleText(assistantNode, assistantText);
      if (reasoningText) {
        updateReasoningPanel(reasoningPanel, reasoningText, false);
      } else {
        reasoningPanel.meta.textContent = "无可展示内容";
        reasoningPanel.preview.textContent = "当前模型未返回可展示的思考内容。";
        reasoningPanel.full.textContent = "";
        reasoningPanel.full.hidden = true;
        reasoningPanel.toggle.hidden = true;
        reasoningPanel.container.dataset.expanded = "false";
      }
      appState.history.push({role: "assistant", content: assistantText});
      appState.turns += 1;
      renderRuntimeChips();

      if (result.errorText) {
        setStatus("请求失败，请稍后重试。", true);
      } else if (result.warningText) {
        setStatus(result.warningText, false);
      } else {
        setStatus("回复完成。");
      }

      sendButton.disabled = false;
    }

    function resetConversation() {
      appState.turns = 0;
      appState.history = [];
      chatFeed.innerHTML = "";
      pushBubble("assistant", "会话已清空。继续输入新的测试问题。");
      renderRuntimeChips();
      setStatus("会话已清空。");
    }

    function resetConversationOnSwitch(targetProfile, targetModel) {
      appState.turns = 0;
      appState.history = [];
      chatFeed.innerHTML = "";
      pushBubble("assistant", `已切换到 ${targetProfile} / ${targetModel}，上下文已重置。`);
      renderRuntimeChips();
      setStatus("模型已切换，上下文已重置。");
    }

    profileSelect.addEventListener("change", () => {
      if (appState.suppressSwitchHandlers) {
        return;
      }
      const nextProfile = profileSelect.value;
      const profileItem = appState.profileCatalog[nextProfile];
      const nextModel = (profileItem?.models || [profileItem?.default_model || appState.model])[0];
      askSaveBeforeSwitch(nextProfile, nextModel);

      appState.profile = profileSelect.value;
      populateModelOptions(appState.profile, "");
      resetConversationOnSwitch(appState.profile, appState.model);
      renderRuntimeChips();
    });

    modelSelect.addEventListener("change", () => {
      if (appState.suppressSwitchHandlers) {
        return;
      }
      const nextModel = modelSelect.value;
      askSaveBeforeSwitch(appState.profile, nextModel);
      appState.model = modelSelect.value;
      resetConversationOnSwitch(appState.profile, appState.model);
      renderRuntimeChips();
    });

    temperatureRange.addEventListener("input", updateRanges);
    topPRange.addEventListener("input", updateRanges);

    thinkingToggle.addEventListener("click", () => {
      appState.thinking = !appState.thinking;
      thinkingToggle.dataset.on = String(appState.thinking);
      setStatus(appState.thinking ? "思考模式已开启。" : "思考模式已关闭。");
    });

    streamToggle.addEventListener("click", () => {
      appState.stream = !appState.stream;
      streamToggle.dataset.on = String(appState.stream);
      renderRuntimeChips();
      setStatus(appState.stream ? "实时输出已开启。" : "实时输出已关闭。");
    });

    clearButton.addEventListener("click", resetConversation);

    composerForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      await handleSend();
    });

    userInput.addEventListener("keydown", async (event) => {
      if (event.key === "Enter" && !event.shiftKey && !event.isComposing && event.keyCode !== 229) {
        event.preventDefault();
        await handleSend();
      }
    });

    thinkingToggle.dataset.on = String(appState.thinking);
    streamToggle.dataset.on = String(appState.stream);
    renderRuntimeChips();
    updateRanges();
    bootstrapRuntime();
  </script>
</body>
</html>
